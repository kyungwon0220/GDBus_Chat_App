/*
 * Generated by gdbus-codegen-glibmm 2.42.0. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#include "chat_management_api_proxy.h"

#include <utility>

template<class T>
inline T specialGetter(Glib::Variant<T> variant)
{
    return variant.get();
}

template<>
inline std::string specialGetter(Glib::Variant<std::string> variant)
{
    // String is not guaranteed to be null-terminated, so don't use ::get()
    gsize n_elem;
    gsize elem_size = sizeof(char);
    char* data = (char*)g_variant_get_fixed_array(variant.gobj(), &n_elem, elem_size);

    return std::string(data, n_elem);
}

/**
 * Methods
 */
void App::ChatMessenger::interface::ManagementProxy::RegisterUser(
    const Glib::ustring & arg_user_name,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = ManagementTypeWrap::RegisterUser_pack(
        arg_user_name);

    m_proxy->call("RegisterUser", callback, cancellable, base, timeout_msec);
}

void App::ChatMessenger::interface::ManagementProxy::RegisterUser_finish(
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);
}

void
App::ChatMessenger::interface::ManagementProxy::RegisterUser_sync(
    const Glib::ustring & arg_user_name,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = ManagementTypeWrap::RegisterUser_pack(
        arg_user_name);

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("RegisterUser", cancellable, base, timeout_msec);

}

void App::ChatMessenger::interface::ManagementProxy::GetChatList(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    m_proxy->call("GetChatList", callback, cancellable, base, timeout_msec);
}

void App::ChatMessenger::interface::ManagementProxy::GetChatList_finish(
    std::vector<Glib::ustring> &out_chat_list,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<std::vector<Glib::ustring>> out_chat_list_v;
    wrapped.get_child(out_chat_list_v, 0);
    out_chat_list = out_chat_list_v.get();
}

std::vector<Glib::ustring>
App::ChatMessenger::interface::ManagementProxy::GetChatList_sync(
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("GetChatList", cancellable, base, timeout_msec);

    std::vector<Glib::ustring> out_chat_list;
    Glib::Variant<std::vector<Glib::ustring>> out_chat_list_v;
    wrapped.get_child(out_chat_list_v, 0);
    out_chat_list = out_chat_list_v.get();
    return out_chat_list;
}

/**
 * 반환값: 채팅방 목록
 */
void App::ChatMessenger::interface::ManagementProxy::CreateChat(
    const Glib::ustring & arg_chat_title,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = ManagementTypeWrap::CreateChat_pack(
        arg_chat_title);

    m_proxy->call("CreateChat", callback, cancellable, base, timeout_msec);
}

void App::ChatMessenger::interface::ManagementProxy::CreateChat_finish(
    Glib::ustring &out_chat_title,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<Glib::ustring> out_chat_title_v;
    wrapped.get_child(out_chat_title_v, 0);
    out_chat_title = out_chat_title_v.get();
}

Glib::ustring
App::ChatMessenger::interface::ManagementProxy::CreateChat_sync(
    const Glib::ustring & arg_chat_title,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = ManagementTypeWrap::CreateChat_pack(
        arg_chat_title);

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("CreateChat", cancellable, base, timeout_msec);

    Glib::ustring out_chat_title;
    Glib::Variant<Glib::ustring> out_chat_title_v;
    wrapped.get_child(out_chat_title_v, 0);
    out_chat_title = out_chat_title_v.get();
    return out_chat_title;
}

/**
 * 반환값: 생성된 채팅방의 제목 // 생성자의 즉시 입장을 위해
 */
void App::ChatMessenger::interface::ManagementProxy::JoinChat(
    const Glib::ustring & arg_chat_title,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = ManagementTypeWrap::JoinChat_pack(
        arg_chat_title);

    m_proxy->call("JoinChat", callback, cancellable, base, timeout_msec);
}

void App::ChatMessenger::interface::ManagementProxy::JoinChat_finish(
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);
}

void
App::ChatMessenger::interface::ManagementProxy::JoinChat_sync(
    const Glib::ustring & arg_chat_title,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = ManagementTypeWrap::JoinChat_pack(
        arg_chat_title);

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("JoinChat", cancellable, base, timeout_msec);

}

void App::ChatMessenger::interface::ManagementProxy::LeaveChat(
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    m_proxy->call("LeaveChat", callback, cancellable, base, timeout_msec);
}

void App::ChatMessenger::interface::ManagementProxy::LeaveChat_finish(
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);
}

void
App::ChatMessenger::interface::ManagementProxy::LeaveChat_sync(
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("LeaveChat", cancellable, base, timeout_msec);

}

/**
 * 인자 없음
 */
void App::ChatMessenger::interface::ManagementProxy::GetUserList(
    const Glib::ustring & arg_chat_title,
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = ManagementTypeWrap::GetUserList_pack(
        arg_chat_title);

    m_proxy->call("GetUserList", callback, cancellable, base, timeout_msec);
}

void App::ChatMessenger::interface::ManagementProxy::GetUserList_finish(
    std::vector<Glib::ustring> &out_user_list,
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<std::vector<Glib::ustring>> out_user_list_v;
    wrapped.get_child(out_user_list_v, 0);
    out_user_list = out_user_list_v.get();
}

std::vector<Glib::ustring>
App::ChatMessenger::interface::ManagementProxy::GetUserList_sync(
    const Glib::ustring & arg_chat_title,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    base = ManagementTypeWrap::GetUserList_pack(
        arg_chat_title);

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("GetUserList", cancellable, base, timeout_msec);

    std::vector<Glib::ustring> out_user_list;
    Glib::Variant<std::vector<Glib::ustring>> out_user_list_v;
    wrapped.get_child(out_user_list_v, 0);
    out_user_list = out_user_list_v.get();
    return out_user_list;
}

/**
 * Signals
 */

/**
 * 접속한 채팅방명
 */

void App::ChatMessenger::interface::ManagementProxy::handle_signal(const Glib::ustring&/* sender_name */,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
    static_cast<void>(signal_name); // maybe unused
    static_cast<void>(parameters); // maybe unused

    if (signal_name == "ChatListUpdated") {
        if (parameters.get_n_children() != 1) return;
        Glib::Variant<std::vector<Glib::ustring>> base_chat_list;
        parameters.get_child(base_chat_list, 0);
        std::vector<Glib::ustring> p_chat_list;
        p_chat_list = base_chat_list.get();

        ChatListUpdated_signal.emit((p_chat_list));
    }
    if (signal_name == "UserJoined") {
        if (parameters.get_n_children() != 2) return;
        Glib::Variant<Glib::ustring> base_user_name;
        parameters.get_child(base_user_name, 0);
        Glib::ustring p_user_name;
        p_user_name = base_user_name.get();

        if (parameters.get_n_children() != 2) return;
        Glib::Variant<Glib::ustring> base_chat_title;
        parameters.get_child(base_chat_title, 1);
        Glib::ustring p_chat_title;
        p_chat_title = base_chat_title.get();

        UserJoined_signal.emit((p_user_name), (p_chat_title));
    }
    if (signal_name == "UserLeft") {
        if (parameters.get_n_children() != 2) return;
        Glib::Variant<Glib::ustring> base_user_name;
        parameters.get_child(base_user_name, 0);
        Glib::ustring p_user_name;
        p_user_name = base_user_name.get();

        if (parameters.get_n_children() != 2) return;
        Glib::Variant<Glib::ustring> base_chat_title;
        parameters.get_child(base_chat_title, 1);
        Glib::ustring p_chat_title;
        p_chat_title = base_chat_title.get();

        UserLeft_signal.emit((p_user_name), (p_chat_title));
    }
}

void App::ChatMessenger::interface::ManagementProxy::handle_properties_changed(
    const Gio::DBus::Proxy::MapChangedProperties &changed_properties,
    const std::vector<Glib::ustring> &/* invalidated_properties */)
{
    static_cast<void>(changed_properties); // maybe unused

    // Only check changed_properties since value will already be cached. Glib can be setup to get
    // values of invalidated properties in which case property will be in changed_properties when
    // value is actually received. See Gio::DBus::ProxyFlags::PROXY_FLAGS_GET_INVALIDATED_PROPERTIES .

}

App::ChatMessenger::interface::ManagementProxy::ManagementProxy(const Glib::RefPtr<Gio::DBus::Proxy> &proxy) : m_proxy(proxy)
{
    m_proxy->signal_signal().connect(sigc::mem_fun(this, &ManagementProxy::handle_signal));
    m_proxy->signal_properties_changed().
        connect(sigc::mem_fun(this, &ManagementProxy::handle_properties_changed));
}

void App::ChatMessenger::interface::ManagementProxy::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "App.ChatMessenger.interface.Management",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<App::ChatMessenger::interface::ManagementProxy> App::ChatMessenger::interface::ManagementProxy::createForBusFinish(const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    App::ChatMessenger::interface::ManagementProxy *p =
        new App::ChatMessenger::interface::ManagementProxy(proxy);
    return Glib::RefPtr<App::ChatMessenger::interface::ManagementProxy>(p);
}

Glib::RefPtr<App::ChatMessenger::interface::ManagementProxy> App::ChatMessenger::interface::ManagementProxy::createForBus_sync(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_sync(busType,
            name,
            objectPath,
            "App.ChatMessenger.interface.Management",
            cancellable,
            Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
            proxyFlags);
    App::ChatMessenger::interface::ManagementProxy *p =
        new App::ChatMessenger::interface::ManagementProxy(proxy);
    return Glib::RefPtr<App::ChatMessenger::interface::ManagementProxy>(p);
}
